/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 * vim: set ts=8 sw=4 et tw=0 ft=C:
 *
 * ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is SpiderMonkey nanojit.
 *
 * The Initial Developer of the Original Code is
 * the Mozilla Corporation.
 * Portions created by the Initial Developer are Copyright (C) 2008
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Jeff Walden <jwalden+code@mit.edu>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

/*
 * Definitions of LIR opcodes.  If you need to allocate an opcode, claim one 
 * starting with "__".
 *
 * Includers must define OPDEF and OPDEF64 macros of the following forms:
 *
 * #define   OPDEF(op,val,operands,repkind) ...
 * #define OPDEF64(op,val,operands,repkind) ...
 *
 * Selected arguments can then be used within the macro expansions.
 *
 * Field        Description
 * op           Bytecode name, token-pasted after "LIR_" to form an LOpcode.
 * val          Bytecode value, which is the LOpcode enumerator value.
 * operands     Number of operands for this instruction, where an "operand" is
 *              a LIns* argument.  Eg. LIR_sti has 3 fields, but the last is an
 *              immediate, so it only has two operands.  Call instructions are
 *              considered to have 0 operands -- the call args aren't counted.
 *              The value is set to -1 for unused opcodes to make it obvious
 *              that it needs changing if the opcode becomes used.
 * repkind      Indicates how the instruction is represented in memory;  XYZ
 *              corresponds to LInsXYZ and LRK_XYZ.
 * isStmt       If 1, the removal of the instruction from a LIR fragment could
 *              change the behaviour of that fragment, even if any value
 *              computed by the instruction is not used later in the fragment.
 *              In other words, can the instruction possibly alter control
 *              flow or memory?  Note, we assume that loads will never fault
 *              and hence cannot affect the control flow.
 *
 * This file is best viewed with 128 columns:
12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678
 */

/*    op    val name        operands */

/* special operations (must be 0..N) */
OPDEF(start,     0, 0, Op0,  0) // start of a fragment
OPDEF(__1,       1,-1, None, 0)
OPDEF(skip,      2, 1, Sk,   0) // holds blobs ("payloads") of data;  also links pages
OPDEF(__3,       3,-1, None, 0)
OPDEF(__4,       4,-1, None, 0)
OPDEF(__5,       5,-1, None, 0)
OPDEF(__6,       6,-1, None, 0)

/* non-pure operations */
OPDEF(addp,      7, 2, Op2,  0) // integer addition for temporary pointer calculations
OPDEF(param,     8, 0, P,    0) // load a parameter
OPDEF(__9,       9,-1, None, 0)
OPDEF(ld,       10, 2, Ld,   0) // 32-bit load
OPDEF(alloc,    11, 0, I,    0) // alloca some stack space
OPDEF(sti,      12, 2, Sti,  1) // 32-bit store
OPDEF(ret,      13, 1, Op1,  1) // return a word-sized value
OPDEF(live,     14, 1, Op1,  1) // extend live range of reference
OPDEF(__15,     15, 0, C,    0)
OPDEF(call,     16, 0, C,    1) // subroutine call returning a 32-bit value

/* guards */
OPDEF(loop,     17, 0, Op2,  1) // loop fragment
OPDEF(x,        18, 0, Op2,  1) // exit always

/* branches */
OPDEF(j,        19, 0, Op2,  1) // jump always
OPDEF(jt,       20, 1, Op2,  1) // jump if true
OPDEF(jf,       21, 1, Op2,  1) // jump if false
OPDEF(label,    22, 0, Op0,  1) // a jump target (no machine code is emitted for this)
OPDEF(ji,       23,-1, None, 0) // indirect jump (currently not implemented)

/* operators */

/*
 * NB: Opcodes LIR_int through LIR_uge must remain continuous to aid in
 *     common-subexpression-elimination detection code.
 */

OPDEF(int,      24, 0, I,    0) // constant 32-bit integer
OPDEF(cmov,     25, 3, Op3,  0) // conditional move: cmov(cond,iftrue,iffalse)
#if defined(NANOJIT_64BIT)
OPDEF(callh,    26,-1, None, 0) // unused on 64-bit machines
#else
OPDEF(callh,    26, 1, Op1,  0) // get the high 32 bits of a call returning a 64-bit value
#endif

/*
 * feq though fge must only be used on float arguments.  They return integers.
 * For all except feq, (op ^ 1) is the op which flips the
 * left and right sides of the comparison, so (lt ^ 1) == gt, or the operator
 * "<" is xored with 1 to get ">".  Similarly, (op ^ 3) is the complement of
 * op, so (lt ^ 1) == ge, or the complement of the operator "<" is ">=" xored
 * with 3.  NB: These opcodes must remain continuous so that comparison-opcode
 * detection works correctly.
 */
OPDEF(feq,      27, 2, Op2,  0) // floating-point equality
OPDEF(flt,      28, 2, Op2,  0) // floating-point less-than
OPDEF(fgt,      29, 2, Op2,  0) // floating-point greater-than
OPDEF(fle,      30, 2, Op2,  0) // floating-point less-than-or-equal
OPDEF(fge,      31, 2, Op2,  0) // floating-point greater-than-or-equal

OPDEF(ldcb,     32, 2, Ld,   0) // non-volatile  8-bit load
OPDEF(ldcs,     33, 2, Ld,   0) // non-volatile 16-bit load
OPDEF(ldc,      34, 2, Ld,   0) // non-volatile 32-bit load

OPDEF(neg,      35, 1, Op1,  0) // integer negation
OPDEF(add,      36, 2, Op2,  0) // integer addition
OPDEF(sub,      37, 2, Op2,  0) // integer subtraction
OPDEF(mul,      38, 2, Op2,  0) // integer multiplication
OPDEF(div,      39, 2, Op2,  0) // integer division
OPDEF(mod,      40, 1, Op1,  0) // hack: get the modulus from a LIR_div result, for x86 only

OPDEF(and,      41, 2, Op2,  0) // 32-bit bitwise AND
OPDEF(or,       42, 2, Op2,  0) // 32-bit bitwise OR
OPDEF(xor,      43, 2, Op2,  0) // 32-bit bitwise XOR
OPDEF(not,      44, 1, Op1,  0) // 32-bit bitwise NOT
OPDEF(lsh,      45, 2, Op2,  0) // 32-bit left shift
OPDEF(rsh,      46, 2, Op2,  0) // 32-bit right shift with sign-extend (>>)
OPDEF(ush,      47, 2, Op2,  0) // 32-bit unsigned right shift (>>>)

// conditional guards, op^1 to complement.  Only things that are
// isCond() can be passed to these.
OPDEF(xt,       48, 1, Op2,  1) // exit if true   (0x30 0011 0000)
OPDEF(xf,       49, 1, Op2,  1) // exit if false  (0x31 0011 0001)

OPDEF(qlo,      50, 1, Op1,  0) // get the low  32 bits of a 64-bit value
OPDEF(qhi,      51, 1, Op1,  0) // get the high 32 bits of a 64-bit value

OPDEF(__52,     52,-1, None, 0)

OPDEF(ov,       53, 1, Op1,  0) // test for overflow;  value must have just been computed

OPDEF(__53,     54,-1, None, 0)

// Integer (all sizes) relational operators.  (op ^ 1) is the op which flips the
// left and right sides of the comparison, so (lt ^ 1) == gt, or the operator
// "<" is xored with 1 to get ">".  Similarly, (op ^ 3) is the complement of
// op, so (lt ^ 1) == ge, or the complement of the operator "<" is ">=" xored
// with 3.  'u' prefix indicates the unsigned integer variant.
// NB: These opcodes must remain continuous so that comparison-opcode detection
// works correctly.
OPDEF(eq,       55, 2, Op2,  0) //          integer equality
OPDEF(lt,       56, 2, Op2,  0) //   signed integer less-than             (0x38 0011 1000)
OPDEF(gt,       57, 2, Op2,  0) //   signed integer greater-than          (0x39 0011 1001)
OPDEF(le,       58, 2, Op2,  0) //   signed integer less-than-or-equal    (0x3A 0011 1010)
OPDEF(ge,       59, 2, Op2,  0) //   signed integer greater-than-or-equal (0x3B 0011 1011)
OPDEF(ult,      60, 2, Op2,  0) // unsigned integer less-than             (0x3C 0011 1100)
OPDEF(ugt,      61, 2, Op2,  0) // unsigned integer greater-than          (0x3D 0011 1101)
OPDEF(ule,      62, 2, Op2,  0) // unsigned integer less-than-or-equal    (0x3E 0011 1110)
OPDEF(uge,      63, 2, Op2,  0) // unsigned integer greater-than-or-equal (0x3F 0011 1111)

OPDEF64(__0b,    0,-1, None, 0)

OPDEF64(file,    1, 2, Op1,  0) // source filename for debug symbols
OPDEF64(line,    2, 2, Op1,  0) // source line number for debug symbols 
OPDEF64(xbarrier,3, 1, Op2,  1) // memory barrier;  doesn't exit, but flushes all values to the stack
OPDEF64(xtbl,    4, 1, Op2,  1) // exit via indirect jump

OPDEF64(__5b,    5,-1, None, 0)
OPDEF64(__6b,    6,-1, None, 0)
OPDEF64(__7b,    7,-1, None, 0)
OPDEF64(__8b,    8,-1, None, 0)
OPDEF64(__9b,    9,-1, None, 0)

OPDEF64(ldq, LIR_ld, 2, Ld,  0) // 64-bit (quad) load

OPDEF64(__11b,  11,-1, None, 0)

OPDEF64(stqi, LIR_sti, 2, Sti, 1)    // 64-bit (quad) store
OPDEF64(fret, LIR_ret, 1, Op1, 1)

OPDEF64(__14b,  14,-1, None, 0)
OPDEF64(__15b,  15,-1, None, 0)

OPDEF64(fcall, LIR_call,  0, C, 1)  // subroutine call returning 64-bit (quad) value

OPDEF64(__17b,  17,-1, None, 0)
OPDEF64(__18b,  18,-1, None, 0)
OPDEF64(__19b,  19,-1, None, 0)
OPDEF64(__20b,  20,-1, None, 0)
OPDEF64(__21b,  21,-1, None, 0)
OPDEF64(__22b,  22,-1, None, 0)
OPDEF64(__23b,  23,-1, None, 0)

// We strip off the 64 bit flag and compare that the opcode is between LIR_int
// and LIR_uge to decide whether we can CSE the opcode. All opcodes below
// this marker are subject to CSE.

OPDEF64(quad,  LIR_int,  0, I64, 0) // 64-bit (quad) constant value
OPDEF64(qcmov, LIR_cmov, 3, Op3, 0) // 64-bit conditional move

OPDEF64(__26b,  26,-1, None, 0)
OPDEF64(__27b,  27,-1, None, 0)
OPDEF64(__28b,  28,-1, None, 0)
OPDEF64(__29b,  29,-1, None, 0)
OPDEF64(__30b,  30,-1, None, 0)
OPDEF64(__31b,  31,-1, None, 0)
OPDEF64(__32b,  32,-1, None, 0)
OPDEF64(__33b,  33,-1, None, 0)

OPDEF64(ldqc, LIR_ldc, 2, Ld, 0)    // non-volatile 64-bit load

OPDEF64(fneg, LIR_neg, 1, Op1, 0)   // floating-point negation
OPDEF64(fadd, LIR_add, 2, Op2, 0)   // floating-point addition
OPDEF64(fsub, LIR_sub, 2, Op2, 0)   // floating-point subtraction
OPDEF64(fmul, LIR_mul, 2, Op2, 0)   // floating-point multiplication
OPDEF64(fdiv, LIR_div, 2, Op2, 0)   // floating-point division
OPDEF64(fmod, LIR_mod, 2, Op2, 0)   // floating-point modulus(?)

OPDEF64(qiand,  41, 2, Op2,  0) // 64-bit bitwise AND
OPDEF64(qiadd,  42, 2, Op2,  0) // 64-bit bitwise ADD
OPDEF64(qior,   43, 2, Op2,  0) // 64-bit bitwise OR

OPDEF64(qilsh,  44, 2, Op2,  0) // 64-bit left shift
OPDEF64(qjoin,  45, 2, Op2,  0) // join two 32-bit values (1st arg is low bits, 2nd is high)

OPDEF64(i2f,    46, 1, Op1,  0) // convert a signed 32-bit integer to a float
OPDEF64(u2f,    47, 1, Op1,  0) // convert an unsigned 32-bit integer to a float

OPDEF64(__48b,  48,-1, None, 0)
OPDEF64(__49b,  49,-1, None, 0)
OPDEF64(__50b,  50,-1, None, 0)
OPDEF64(__51b,  51,-1, None, 0)
OPDEF64(__52b,  52,-1, None, 0)
OPDEF64(__53b,  53,-1, None, 0)
OPDEF64(__54b,  54,-1, None, 0)
OPDEF64(__55b,  55,-1, None, 0)
OPDEF64(__56b,  56,-1, None, 0)
OPDEF64(__57b,  57,-1, None, 0)
OPDEF64(__58b,  58,-1, None, 0)
OPDEF64(__59b,  59,-1, None, 0)
OPDEF64(__60b,  60,-1, None, 0)
OPDEF64(__61b,  61,-1, None, 0)
OPDEF64(__62b,  62,-1, None, 0)
OPDEF64(__63b,  63,-1, None, 0)
